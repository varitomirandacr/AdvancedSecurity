trait FormulaBase {
    const hundred := 100 as real;
    const twenty := 20 as real;
    const fifteen := 15 as real;
    const ten := 10 as real;
    const five := 5 as real;
    const four := 4 as real;
    const three := 3 as real;
    const zero := 0 as real;
    const one := 1 as real;

    method funcImpact(impact:real) returns (result:real)
        requires zero <= impact && impact <= one
        ensures impact == zero ==> result == zero
        ensures impact != zero ==> result == one
        ensures result >= zero && result <= one
    {
        assert zero <= impact && impact <= one;
        if impact == zero { result:= zero; } else { result:= one; }
        assert impact == zero ==> result == zero;
        assert impact != zero ==> result == one;
    }
}

class BaseFinding extends FormulaBase {    
    var technicalImpact :real;
    var acquiredProvilege :real;
    var acquiredProvilegeLayer :real;
    var findingConfidence :real;
    var internalControlEffectiveness :real;

    constructor(ti:real, ap: real, al:real, ic:real, fc:real)
        ensures technicalImpact == ti
        ensures acquiredProvilege == ap
        ensures acquiredProvilegeLayer == al
        ensures internalControlEffectiveness == ic
        ensures findingConfidence == fc
    {
        technicalImpact := ti;
        acquiredProvilege := ap;
        acquiredProvilegeLayer := al;
        internalControlEffectiveness := ic;
        findingConfidence := fc;
    }

    method funcBaseFinding() returns (baseFinding:real)
        requires zero <= technicalImpact <= one
        requires zero <= acquiredProvilege <= one
        requires zero <= acquiredProvilegeLayer <= one
        requires zero <= internalControlEffectiveness <= one
        requires zero <= findingConfidence <= one
        ensures zero <= baseFinding <= hundred
    {
        var fti := funcImpact(technicalImpact);
        assert zero <= fti <= one;
        
        var block1 := (ten * technicalImpact);
        var block2 := (five * (acquiredProvilege + acquiredProvilegeLayer));
        var block3 := (five * findingConfidence);
        var block4 := (block1 + block2);
        var block5 := (block4 + block3);
        var block6 := (block5 * fti);
        var block7 := (block6 * internalControlEffectiveness);
        baseFinding := block5 * four;

        assert zero <= block1 <= hundred;
        assert zero <= block2 <= hundred;
        assert zero <= block3 <= hundred;
        assert zero <= block4 <= hundred;
        assert zero <= block5 <= hundred;
        assert zero <= block6 <= hundred;
        assert zero <= baseFinding <= hundred;
    }
}

class AttackSurface extends FormulaBase {
    var requiredPrivilege : real;
    var requiredPrivilegeLayer : real;
    var accessVector : real;
    var authenticationStrenght : real;
    var levelOfInteraction : real;
    var deploymentScope : real;

    constructor (rp:real, rl:real, av:real, asn:real, lin:real, sc:real) 
        ensures requiredPrivilege == rp
        ensures requiredPrivilegeLayer == rl
        ensures accessVector == av
        ensures authenticationStrenght == asn
        ensures levelOfInteraction == lin
        ensures deploymentScope == sc
    { 
        requiredPrivilege := rp;
        requiredPrivilegeLayer := rl;
        accessVector := av;
        authenticationStrenght := asn;
        levelOfInteraction := lin;
        deploymentScope := sc;
    }

    method funcAttackSurface() returns (attackSurface:real)
        requires zero <= requiredPrivilege <= one
        requires zero <= requiredPrivilegeLayer <= one
        requires zero <= accessVector <= one
        requires zero <= deploymentScope <= one
        requires zero <= levelOfInteraction <= one
        requires zero <= authenticationStrenght <= one
        ensures zero <= attackSurface <= one
    {        
        var block1 := (requiredPrivilege + requiredPrivilegeLayer + accessVector);
        var block2 := (twenty * block1);
        var block3 := (twenty * deploymentScope);
        var block4 := (fifteen * levelOfInteraction);
        var block5 := (five * authenticationStrenght);
        var block6 := (block2 + block3);
        var block7 := (block6 + block4);
        var block8 := (block7 + block5);
        attackSurface := (block8 / twenty);
        assert zero <= attackSurface <= one ==> (attackSurface / hundred) <= one;   
    } 
}

class Environmental extends FormulaBase {
    var businessImpact:real;
    var likelihoodOfDiscovery:real;
    var likelihoodOfExploit:real;
    var prevalence:real;
    var externalControlEffectiveness:real;

    constructor (bi:real, di:real, ex:real, ec:real, p:real) 
        ensures businessImpact == bi
        ensures likelihoodOfDiscovery == di
        ensures likelihoodOfExploit == ex
        ensures externalControlEffectiveness == ec
        ensures prevalence == p
    {
        businessImpact := bi;
        likelihoodOfDiscovery := di;
        likelihoodOfExploit := ex;
        externalControlEffectiveness := ec;
        prevalence := p;
    }

    method funcEnvironmental() returns (environmental:real)
        requires zero <= businessImpact <= one
        requires zero <= likelihoodOfDiscovery <= one
        requires zero <= likelihoodOfExploit <= one
        requires zero <= prevalence <= one
        requires zero <= externalControlEffectiveness <= one
        ensures zero <= environmental <= one
    {        
        var fbi := funcImpact(businessImpact);
        assert zero <= fbi <= one;

        var block1 := (ten * businessImpact);
        var block2 := (three * likelihoodOfDiscovery);
        var block3 := (four * likelihoodOfExploit);
        var block4 := (three * prevalence);
        var block5 := (block1 + block2 + block3 + block4);
        var block6 := (block5 * fbi);
        var block7 := (block6 * externalControlEffectiveness);
        environmental := (block7 / twenty);
    } 
}

class CWSS extends FormulaBase {

    constructor () { }
    
    method CalculateBaseFinding(ti:real, ap:real, al:real, ic:real, fc:real) returns (baseFinding:real)
        requires zero <= ti <= one
        requires zero <= ap <= one
        requires zero <= al <= one
        requires zero <= ic <= one
        requires zero <= fc <= one
        ensures zero <= baseFinding <= hundred
    {
        var bf := new BaseFinding(ti, ap, al, ic, fc);
        baseFinding := bf.funcBaseFinding();
    }

    method CalculateAttackSurface(rp:real, rl:real, av:real, asn:real, lin:real, sc:real) returns (attackSurface:real) 
        requires zero <= rp <= one
        requires zero <= rl <= one
        requires zero <= av <= one
        requires zero <= asn <= one
        requires zero <= lin <= one
        requires zero <= sc <= one
        ensures zero <= attackSurface <= one
    {
        var surface := new AttackSurface(rp, rl, av, asn, lin, sc);
        attackSurface := surface.funcAttackSurface();
    }

    method CalculateEnvironmental(bi:real, di:real, ex:real, ec:real, p:real) returns (environmental:real) 
        requires zero <= bi <= one
        requires zero <= di <= one
        requires zero <= ex <= one
        requires zero <= ec <= one
        requires zero <= p <= one
        ensures zero <= environmental <= one
    {
        var env := new Environmental(bi, di, ex, ec, p);
        environmental := env.funcEnvironmental();
    }    

    /*lemma CalculateCWSS() returns (cwss:real) 
        //ensures zero <= cwss <= oneHundred
    {
        var bf := CalculateBaseFinding(1.0,1.0,0.2,1.0,1.0);
        //assert zero <= bf <= oneHundred;
        var asf := CalculateAttackSurface(1.0,1.0,1.0,1.0,1.0,1.0);
        //assert zero <= asf <= one;
        var env :=  CalculateEnvironmental(1.0,1.0,1.0,1.0,1.0);
        //assert zero <= env <= one;
        cwss := (bf*asf*env);
        //assert zero <= cwss <= oneHundred; 
    }*/
}

